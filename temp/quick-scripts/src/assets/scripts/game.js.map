{"version":3,"sources":["assets/scripts/game.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["// Learn TypeScript:\n//  - https://docs.cocos.com/creator/manual/en/scripting/typescript.html\n// Learn Attribute:\n//  - https://docs.cocos.com/creator/manual/en/scripting/reference/attributes.html\n// Learn life-cycle callbacks:\n//  - https://docs.cocos.com/creator/manual/en/scripting/life-cycle-callbacks.html\n\n//定义数据类型\nclass AStarNode {\n    /** 行坐标 **/\n    x: number\n    /** 列坐标 **/\n    y: number\n    /** 已使用步数 ：从开始节点到当前节点已使用的步数 **/\n    usedSteps: number = 0\n    /** 预估距离 ：当前节点到目标节点无视障碍的距离 **/\n    distance: number\n    /** 期望步数 = 已使用步数+无障碍距离 **/\n    expectedSteps: number\n    /** 父节点：打印路径时需要 **/\n    parent: AStarNode\n    //代表斜角度\n    isDiag: boolean = false\n\n    startNode: cc.Node\n\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n\n}\n\nconst { ccclass, property } = cc._decorator;\n\n@ccclass\nexport default class Game extends cc.Component {\n\n    @property(cc.Label)\n    label: cc.Label = null;\n\n    @property\n    text: string = 'hello';\n    private _startNode: AStarNode;\n    private _endNode: AStarNode  // 目标点\n    private _straightCost: number = 1.0;     //上下左右走的代价\n    private _diagCost: number = Math.SQRT2;  //斜着走的代价 \n    private _cellSize: number = 30\n    private _bg: cc.Node\n    private _wall: Array<cc.Node> //墙的节点\n    //定义八方向 [x y]\n    private stepArray: Array<Array<number>> = [[0, -1], [0, 1], [1, 0], [-1, 0], [1, 1], [-1, -1], [1, -1], [-1, 1]]\n    // LIFE-CYCLE CALLBACKS:\n    //待访问节点\n    private readyList: Array<AStarNode> = []\n    private visitedList: Array<AStarNode> = []\n    //找邻居节点\n    private findNeighbour(node: AStarNode) {\n        //初始化node\n        let resultList = []\n        // 获取8个节点的坐标并判断有效性\n        for (let index = 0; index < 8; index++) {\n            let step = this.stepArray[index]\n            let isDiag = false\n            if (step[0] != 0 && step[1] != 0) {\n                isDiag = true  //代表斜着的方向\n            }\n            let r = this._cellSize\n            if (isDiag) {\n                r = this._cellSize * this._diagCost\n            }\n            let x = node.x + (step[0] * r)\n            let y = node.y + (step[1] * r)\n            // 坐标越界判断\n            console.log(x, y)\n            if (Math.abs(x) > (this._bg.x / 2 - 30) || Math.abs(y) > 300) {\n                continue\n            }\n            //监测是否是碰撞的\n            if (this.testOverlay(x, y)) {\n                continue\n            }\n            //判断是否在已访问节点\n            if (this.findNode(this.visitedList, x, y) != null) {\n                continue\n            }\n            let nnode = new AStarNode(x, y)\n            nnode.isDiag = isDiag\n            resultList.push(nnode)\n            //判断是不是碰撞到终点-不在这里\n        }\n        return resultList\n    }\n\n    //搜索核心逻辑\n    private aStarSearch():AStarNode{\n        let haveEndNode = null\n        this.readyList.push(this._startNode)\n        while (this.readyList.length > 0) {\n            const minNode = this.getMinNode(this.readyList);\n            this.readyList = this.removeListNode(this.readyList, minNode)\n            this.visitedList.push(minNode)\n            let list = this.findNeighbour(minNode);  //找相邻节点\n            for (let index = 0; index < list.length; index++) {\n                let neighbourNode = list[index];\n                this.initNode(minNode,neighbourNode)\n                let tmpNode = this.findNode(this.readyList, neighbourNode.x, neighbourNode.y);\n                if(tmpNode==null){\n                    this.readyList.push(neighbourNode)\n                }else if(neighbourNode.expectedSteps < tmpNode.expectedSteps){\n                    this.readyList = this.removeListNode(this.readyList,tmpNode)\n                    this.readyList.push(neighbourNode)\n                }\n            }\n            //判断是否碰撞到终点\n            haveEndNode= this.findEndNodeByReadList()\n            if(haveEndNode!=null){\n                break\n            }\n        }\n        return haveEndNode\n    }\n    private findEndNodeByReadList(){\n        let _endReadyNode= null\n        for (let index = 0; index < this.readyList.length; index++) {\n            const node = this.readyList[index];\n            if(this.isInEndNode(node.x,node.y)){\n                _endReadyNode=node\n                break\n            }\n        }\n        return _endReadyNode\n    }\n\n    //判断是否碰撞到终点\n    private isInEndNode(x:number,y:number){\n        let minX = this._endNode.x - (this._cellSize / 2);    //正方形格子，比较简单\n        let maxX = this._endNode.x + (this._cellSize / 2);\n        let minY = this._endNode.y - (this._cellSize / 2);   \n        let maxY = this._endNode.y + (this._cellSize / 2);\n        if(x<=maxX&&x>=minX && y<=maxY&& y>=minY){\n            return true\n        }else{\n            return false\n        }\n    }\n\n    //计算节点和期望步数 \n    private initNode(parent: AStarNode,node:AStarNode) {\n        let cost = node.isDiag?this._diagCost:this._straightCost\n       \n        let usedSteps = cost\n        if (parent) {\n            usedSteps = parent.usedSteps + cost;\n        }\n        node.parent = parent\n        node.usedSteps= usedSteps\n        node.distance = this.diagonal(node) //计算距离\n        node.expectedSteps = node.usedSteps+node.distance // 期望步数\n\n    }\n\n    private removeListNode(listNode: Array<AStarNode>, delNode: AStarNode) {\n        let list = []\n        for (let index = 0; index < listNode.length; index++) {\n            const node = listNode[index];\n            if (node.x != delNode.x || node.y != delNode.y) {\n                list.push(list)\n            }\n        }\n        return list\n    }\n\n    //计算期望最小的节点\n    private getMinNode(listNode: Array<AStarNode>) {\n        if (!listNode || listNode.length == 0) {\n            return null\n        } else if (listNode.length == 1) {\n            return listNode[0]\n        }\n        let minNode = listNode[0]\n        for (let index = 0; index < listNode.length; index++) {\n            const node = listNode[index];\n            if (node.expectedSteps < minNode.expectedSteps) {\n                minNode = node;\n            }\n        }\n        return minNode\n    }\n\n\n    //用cocos内置的去监测\n    private testOverlay(x: number, y: number) {\n        let v = new cc.Vec2(x, y)\n        let isHit = false\n        for (let index = 0; index < this._wall.length; index++) {\n            const node = this._wall[index];\n            isHit = node.getBoundingBox().contains(v)\n            //isHit = cc.Intersection.pointInPolygon(v,node.getComponent(cc.BoxCollider).world.points)\n            if (isHit) {\n                break\n            }\n        }\n        return isHit\n    }\n\n    private findNode(listNode: Array<AStarNode>, x: number, y: number) {\n        let haveNode = null\n        for (let index = 0; index < listNode.length; index++) {\n            const node = listNode[index];\n            if (node.x == x && node.y == y) {\n                haveNode = node\n                break\n            }\n        }\n        return haveNode\n    }\n\n    onLoad() {\n        //cc.director.getCollisionManager().enabled = true;\n        this._bg = cc.find('Canvas/Bg');\n        let startNode = cc.find('Canvas/start-node')\n        this._startNode = new AStarNode(startNode.x, startNode.y)\n        this._startNode.startNode = startNode\n        let wall = cc.find(\"Canvas/wall\")\n        this._wall = wall.children\n\n        // var a = new cc.Rect(0, 0, 10, 10);\n        // var b = new cc.Vec2(0, 5);\n        // console.log(a.contains(b))\n        //监控点击\n        this.node.on(cc.Node.EventType.MOUSE_DOWN, this.clickSearch.bind(this))\n    }\n\n    clickSearch(event: cc.Event.EventTouch) {\n        //转换成局部坐标\n        let p = this.node.convertToNodeSpaceAR(event.getLocation())\n        this._endNode = new AStarNode(p.x, p.y)\n\n        let node = this.aStarSearch()\n        if(node ==null){\n            console.log('终点不可达')\n            return\n        }\n        //开始移动方块\n        //构建动作数组\n        let actionArr= []\n        actionArr.push(cc.moveTo(2,new cc.Vec2(node.x,node.y)))\n        while(node.parent!=null){\n             let tmp = node.parent\n             actionArr.push(cc.moveTo(2,new cc.Vec2(tmp.x,tmp.y)))\n             node = tmp\n        }\n        actionArr.reverse()\n        this._startNode.startNode.runAction(cc.sequence(actionArr))\n    }\n\n    // start() {\n\n    // }\n    \n    //曼哈顿算法\n    private manhattan(node: AStarNode) {\n        return Math.abs(node.x - this._endNode.x) * this._straightCost + Math.abs(node.y + this._endNode.y) * this._straightCost;\n    }\n\n    private euclidian(node: AStarNode) {\n        var dx = node.x - this._endNode.x;\n        var dy = node.y - this._endNode.y;\n        return Math.sqrt(dx * dx + dy * dy) * this._straightCost;\n    }\n\n    private diagonal(node: AStarNode) {\n        var dx = Math.abs(node.x - this._endNode.x);\n        var dy = Math.abs(node.y - this._endNode.y);\n        var diag = Math.min(dx, dy);\n        var straight = dx + dy;\n        return this._diagCost * diag + this._straightCost * (straight - 2 * diag);\n    }\n\n    // update (dt) {}\n}\n"]}